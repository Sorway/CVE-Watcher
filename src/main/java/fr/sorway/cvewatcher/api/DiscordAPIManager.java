package fr.sorway.cvewatcher.api;

import fr.sorway.cvewatcher.CVEWatcher;
import fr.sorway.cvewatcher.configuration.Configuration;
import net.dv8tion.jda.api.entities.Activity;
import net.dv8tion.jda.api.hooks.ListenerAdapter;
import net.dv8tion.jda.api.requests.GatewayIntent;
import net.dv8tion.jda.api.sharding.DefaultShardManagerBuilder;
import net.dv8tion.jda.api.sharding.ShardManager;
import net.dv8tion.jda.api.utils.cache.CacheFlag;
import org.reflections.Reflections;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.reflect.InvocationTargetException;
import java.util.Arrays;
import java.util.Set;

public class DiscordAPIManager {
    private final Logger logger = LoggerFactory.getLogger(DiscordAPIManager.class);
    private ShardManager shardManager;

    public void setupBot(Configuration configuration) {
        this.shardManager = DefaultShardManagerBuilder
                .createDefault(configuration.getString("token"))
                .setShardsTotal(-1)
                .setAutoReconnect(true)
                .setLargeThreshold(50)
                .setActivity(Activity.watching("les failles de sÃ©curitÃ© ðŸ‘€"))
                .build();
    }

    public void loadListeners(CVEWatcher cveWatcher) {
        Reflections reflections = new Reflections("fr.sorway.cvewatcher.events");
        Set<Class<? extends ListenerAdapter>> classes = reflections.getSubTypesOf(ListenerAdapter.class);

        for (Class<? extends ListenerAdapter> aClass : classes) {
            logger.info("Loading Listener {}", aClass.getSimpleName());
            try {
                shardManager.addEventListener(aClass.getDeclaredConstructor(CVEWatcher.class).newInstance(cveWatcher));
            } catch (InstantiationException | IllegalAccessException | InvocationTargetException |
                     NoSuchMethodException e) {
                logger.error(e.getMessage(), e);
            }
        }
    }

    public ShardManager getShardManager() {
        return shardManager;
    }
}
