package fr.sorway.cvewatcher.managers;

import com.apptasticsoftware.rssreader.Item;
import fr.sorway.cvewatcher.CVEWatcher;
import fr.sorway.cvewatcher.data.ANSSIVulnerability;
import fr.sorway.cvewatcher.data.CVEVulnerability;
import fr.sorway.cvewatcher.data.Vulnerability;
import fr.sorway.cvewatcher.data.VulnerabilityType;
import fr.sorway.cvewatcher.database.DatabaseManager;
import org.json.JSONArray;
import org.json.JSONObject;

import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class VulnerabilityManager {
    private final DatabaseManager databaseManager;

    public VulnerabilityManager(CVEWatcher cveWatcher) {
        this.databaseManager = cveWatcher.getDatabaseManager();
    }

    public void registerVulnerability(Vulnerability vulnerability) {
        try {
            PreparedStatement statement = databaseManager.getConnection().prepareStatement("INSERT INTO Vulnerabilities (title, type, links, publishedDate, description, source) VALUES (?, ?, ?, ?, ?, ?);");
            statement.setString(1, vulnerability.title());
            statement.setString(2, vulnerability.type().name());
            statement.setString(3, vulnerability.links());
            statement.setString(4, vulnerability.publishedDate());
            statement.setString(5, vulnerability.description());
            statement.setString(6, vulnerability.source().name());
            statement.executeUpdate();
            statement.getConnection().close();
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public boolean checkVulnerability(Vulnerability vulnerability) {
        try {
            PreparedStatement statement = databaseManager.getConnection().prepareStatement("SELECT * FROM Vulnerabilities WHERE title=? AND type=? AND links=? AND publishedDate=? AND source=?;");
            statement.setString(1, vulnerability.title());
            statement.setString(2, vulnerability.type().name());
            statement.setString(3, vulnerability.links());
            statement.setString(4, vulnerability.publishedDate());
            statement.setString(5, vulnerability.source().name());

            boolean result = statement.executeQuery().next();
            statement.getConnection().close();
            return result;
        } catch (SQLException e) {
            return false;
        }
    }

    public List<ANSSIVulnerability> convertANSSIVulnerabilities(VulnerabilityType type, List<Item> items) {
        return items.stream()
                .map(item -> new ANSSIVulnerability(
                        item.getTitle().get(),
                        type,
                        item.getGuid().get(),
                        item.getPubDate().get(),
                        item.getDescription().get().replaceAll("\\<.*?\\>", "")
                ))
                .collect(Collectors.toList());
    }

    public List<CVEVulnerability> convertCVEVulnerabilities(JSONArray items) {
        return IntStream.range(0, items.length())
                .mapToObj(i -> {
                    JSONObject item = items.getJSONObject(i);
                    return new CVEVulnerability(
                            item.getString("id"),
                            VulnerabilityType.VULNERABILITY,
                            item.getJSONArray("references").getString(0),
                            item.getString("Published"),
                            item.getString("summary"),
                            item.getString("cwe"),
                            item.isNull("cvss") ? null : String.valueOf(item.getInt("cvss"))
                    );
                })
                .collect(Collectors.toList());
    }
}
