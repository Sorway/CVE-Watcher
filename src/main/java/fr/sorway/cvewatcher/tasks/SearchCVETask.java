package fr.sorway.cvewatcher.tasks;

import com.apptasticsoftware.rssreader.RssReader;
import fr.sorway.cvewatcher.CVEWatcher;
import fr.sorway.cvewatcher.data.Vulnerability;
import fr.sorway.cvewatcher.database.DatabaseManager;
import fr.sorway.cvewatcher.managers.VulnerabilityManager;
import net.dv8tion.jda.api.EmbedBuilder;
import net.dv8tion.jda.api.entities.Guild;
import net.dv8tion.jda.api.entities.channel.concrete.MediaChannel;
import net.dv8tion.jda.api.entities.channel.concrete.NewsChannel;
import net.dv8tion.jda.api.entities.channel.concrete.TextChannel;
import net.dv8tion.jda.api.entities.channel.middleman.MessageChannel;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.net.http.HttpClient;
import java.time.Instant;
import java.util.List;

public class SearchCVETask implements Runnable {
    private final Logger logger = LoggerFactory.getLogger(SearchCVETask.class);
    private final CVEWatcher cveWatcher;
    private RssReader rssReader;
    private final VulnerabilityManager vulnerabilityManager;

    public SearchCVETask(CVEWatcher cveWatcher) {
        this.cveWatcher = cveWatcher;
        this.vulnerabilityManager = new VulnerabilityManager(cveWatcher);
        initRssReader();
    }

    @Override
    public void run() {
        try {
            logger.info("Finding CVE vulnerabilities.");
            initRssReader();

            List<String> rssUrls = List.of(
                    "https://www.cert.ssi.gouv.fr/feed/",
                    "https://www.cert.ssi.gouv.fr/alerte/feed/"
            );

            for (String rssUrl : rssUrls) {
                List<Vulnerability> items = vulnerabilityManager.convertVulnerability(
                        rssUrl.contains("alerte") ? Vulnerability.Type.ALERT : Vulnerability.Type.VULNERABILITY,
                        rssReader.read(rssUrl).toList()
                );

                for (Vulnerability item : items) {
                    if (!vulnerabilityManager.checkVulnerability(item)) {
                        vulnerabilityManager.registerVulnerability(item);
                        sendMessage(item);
                    }
                }
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private void initRssReader() {
        this.rssReader = new RssReader();
        this.rssReader.addHeader("Cache-Control", "no-cache, no-store, must-revalidate");
        this.rssReader.addHeader("Pragma", "no-cache");
    }

    private void sendMessage(Vulnerability vulnerability) {
        String guildId = cveWatcher.getConfiguration().getString("announcement_guild");
        String channelId = cveWatcher.getConfiguration().getString("announcement_channel");

        if (guildId == null || channelId == null)
            return;

        Guild guild = cveWatcher.getDiscordAPIManager().getShardManager().getGuildById(guildId);
        NewsChannel channel = guild == null ? null : guild.getNewsChannelById(channelId);

        if (channel != null) {
            EmbedBuilder embed = new EmbedBuilder()
                    .setColor(vulnerability.type().getColor())
                    .setTimestamp(Instant.now())
                    .setFooter("Développé par Soso' | Source: ANSSI")
                    .setAuthor(vulnerability.title().replace("[SCADA]", ""), vulnerability.link(), "https://upload.wikimedia.org/wikipedia/fr/thumb/3/31/Anssi.png/600px-Anssi.png?20160208093201")
                    .setDescription(vulnerability.description())
                    .addField("Date de publication:", vulnerability.pubDate(), true)
                    .addField("Type:", vulnerability.type().name(), true);
            channel.sendMessageEmbeds(embed.build()).queue(message -> message.crosspost().queue());
        }
    }
}
